# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability in Qatsi, please report it via GitHub Security Advisories:

**[Report a vulnerability](https://github.com/coignard/qatsi/security/advisories/new)**

Do not open a public issue or email the maintainers directly.

### What to include

- Description of the vulnerability
- Steps to reproduce
- Potential impact
- Suggested fix (if any)

### Response time

- Initial response: 48 hours
- Fix timeline: 7-14 days (depending on severity)

GitHub Security Advisories provide a private communication channel and allow coordinated disclosure before public patching.

## Security Considerations

### Cryptographic Assumptions

Qatsi's security relies on:

1. **Argon2id (RFC 9106)**: Memory-hard KDF designed to resist GPU/ASIC attacks through configurable memory cost, iteration count, and parallelism.

2. **ChaCha20 (RFC 8439)**: Cryptographically secure stream cipher with 256-bit security margin.

3. **Unbiased rejection sampling**: Eliminates modulo bias in character/word selection by rejecting values outside uniform range.

4. **Unicode NFC normalization**: Ensures consistent byte representation regardless of input method (composed vs decomposed forms).

5. **Automatic memory zeroization**: All sensitive data (master secret, layers, salts, derived keys, output) is wrapped in `Zeroizing<T>` and cleared on drop.

### Attack Resistance

**Brute-force resistance:** For an 80-bit master secret with paranoid preset (128 MiB, 32 iterations), expected attack time exceeds 3.8 × 10⁸ years on a cluster of 500 high-end GPUs at 100 hashes/second each.

**Memory-hardness:** Argon2id requires substantial memory per hash attempt, making parallelization expensive. Standard preset uses 64 MiB per derivation; paranoid uses 128 MiB.

**Supply-chain protection:** EFF Large Wordlist is embedded at compile-time with SHA-256 integrity verification. Tampering with the wordlist will cause tests to fail.

### Threat Model

**Qatsi protects against:**

- Offline brute-force attacks (via Argon2id memory-hardness)
- Dictionary attacks (via high-entropy master secret requirement)
- GPU/ASIC acceleration (via memory-hard KDF)
- Wordlist tampering (compile-time SHA-256 verification)
- Memory disclosure on host system (automatic zeroization)
- Vault exfiltration attacks (no vault exists)
- Cloud sync interception (no synchronization)

**Qatsi does NOT protect against:**

- **Master secret compromise:** If your master secret is exposed, all derived passwords are compromised. There is no forward secrecy. This is the fundamental trade-off of stateless design.

- **Keyloggers/screen capture:** If malware observes your master secret during entry, all derived secrets are exposed. Use Qatsi only on trusted systems.

- **Side-channel attacks:** No constant-time guarantees. Timing attacks, cache attacks, and power analysis are not mitigated.

- **$5 wrench attack:** Physical coercion to reveal the master secret defeats all cryptography.

- **Terminal history leaks:** Master secret may appear in shell history if piped from command line. Always use interactive prompts.

### Design Limitations

**No password rotation:** If a derived password is compromised, you cannot regenerate a different one without either changing your master secret (affecting all passwords) or modifying layer inputs (requiring you to remember the modification). Traditional password managers handle this by storing independent passwords.

**No per-site policy accommodation:** Qatsi generates uniform output. Sites with specific requirements (e.g., "exactly 12 characters, no symbols") require manual workarounds or layer variants, which you must remember.

**No 2FA protection:** The master secret is a single factor. Adding TOTP or hardware key verification requires storing state, defeating stateless design.

**Cannot import existing passwords:** If you have passwords not generated by Qatsi, you must either reset them or store them elsewhere.

**Use case:** Qatsi is designed for master passwords (KeePassXC databases, disk encryption, PGP keys) and secrets in constrained environments (air-gapped systems, live boot USBs). For day-to-day website passwords, use a traditional password manager. See [README.md](README.md#design-trade-offs) for detailed trade-offs.

## Known Issues

- **No constant-time operations:** Side-channel attacks are not specifically mitigated
- **No input rate limiting:** Repeated derivation attempts are not throttled (by design, for offline use)
- **No protection against compromised binaries:** If the `qatsi` executable is replaced with malware, it can log your master secret

## Dependencies

Security-critical dependencies:

- `argon2 = "0.5.3"` (Argon2id implementation)
- `chacha20 = "0.9.1"` (ChaCha20 stream cipher)
- `blake2 = "0.10.6"` (BLAKE2b for salt expansion)
- `zeroize = "1.8.2"` (Memory zeroization)

All dependencies are widely-used, actively-maintained crates from the RustCrypto project.

## Audit Status

No formal security audit has been conducted. The codebase is open-source and community review is welcome.
